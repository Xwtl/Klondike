<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Solitaire</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --card-width: 90px;
      --card-height: 130px;
      --tableau-offset-faceup: 26px;
      --tableau-offset-facedown: 12px;
      --pile-gap: 16px;
      --waste-gap: 24px;
      --transition-fast: 0.15s;

      --accent-primary: #f97316;
      --accent-primary-soft: rgba(249, 115, 22, 0.08);
      --accent-primary-strong: rgba(249, 115, 22, 0.7);

      --accent-secondary: rgb(20, 72, 156);
      --accent-secondary-soft: rgba(59, 130, 246, 0.2);
      --accent-secondary-strong: rgba(59, 130, 246, 0.75);

      --bg-gradient-top: #030407;
      --bg-gradient-mid: #020617;
      --bg-gradient-bottom: #000000;

      --bg-panel: #020819;
      --bg-panel-alt: #050b1f;

      --border-soft: rgba(148, 163, 184, 0.3);
      --border-strong: rgba(148, 163, 184, 0.5);
      --border-outer-strong: rgba(15, 23, 42, 0.9);

      --text-primary: #e5e7eb;
      --text-muted: #9ca3af;
      --text-on-accent: #fefce8;
      --text-win: var(--accent-primary);

      --card-front-top: #020617;
      --card-front-bottom: #020b2b;

      --card-back-base: #020617;
      --card-back-glow: var(--accent-secondary);
      --card-back-border: var(--accent-secondary-strong);
      --card-back-inner-border: rgba(59, 130, 246, 0.55);

      --card-hearts-split: #f97316;
      --card-diamonds-split: #f97316;
      --card-spades-split: #e5e7eb;
      --card-clubs-split: #e5e7eb;

      --card-hearts-multi: #f94b16;
      --card-diamonds-multi: #f97316;
      --card-spades-multi: #6092f7;
      --card-clubs-multi: rgb(100, 197, 192);

      --card-hearts: #f97316;
      --card-diamonds: #f97316;
      --card-spades: #e5e7eb;
      --card-clubs: #e5e7eb;

      --shadow-strong: rgba(0, 0, 0, 0.9);
      --shadow-soft: rgba(0, 0, 0, 0.6);
      --shadow-card: rgba(0, 0, 0, 0.7);
      --pip-shadow: 0 0 4px rgba(0, 0, 0, 0.85);

      --pile-bg-main: rgba(15, 23, 42, 0.98);
      --pile-bg-highlight: rgba(15, 23, 42, 0.85);
      --pile-stock-waste-bg: rgba(15, 23, 42, 0.98);
      --pile-inner-border: rgba(15, 23, 42, 0.8);
    }

    body.pips-split {
      --card-hearts: var(--card-hearts-split);
      --card-diamonds: var(--card-diamonds-split);
      --card-spades: var(--card-spades-split);
      --card-clubs: var(--card-clubs-split);
    }

    body.pips-multi {
      --card-hearts: var(--card-hearts-multi);
      --card-diamonds: var(--card-diamonds-multi);
      --card-spades: var(--card-spades-multi);
      --card-clubs: var(--card-clubs-multi);
    }

    body.theme-classic {
      --accent-primary: #16a34a;
      --accent-primary-soft: rgba(11, 48, 20, 0.18);
      --accent-primary-strong: rgba(22, 163, 74, 0.85);

      --accent-secondary: #2563eb;
      --accent-secondary-soft: rgba(64, 141, 81, 0.123);
      --accent-secondary-strong: rgba(37, 99, 235, 0.8);

      --bg-gradient-top: #14532d;
      --bg-gradient-mid: #166534;
      --bg-gradient-bottom: #0f2e1b;

      --bg-panel: rgba(12, 53, 22, 0.904);
      --bg-panel-alt: rgba(33, 77, 39, 0.96);

      --border-soft: rgba(74, 222, 128, 0.35);
      --border-strong: rgba(61, 68, 64, 0.2);
      --border-outer-strong: rgba(6, 78, 59, 0.95);

      --text-primary: #f9fafb;
      --text-muted: #d1fae5;
      --text-on-accent: #f9fafb;
      --text-win: #facc15;

      --card-front-top: #f9fafb;
      --card-front-bottom: #e5e7eb;

      --card-back-base: #1d4ed8;
      --card-back-glow: #60a5fa;
      --card-back-border: #1e40af;
      --card-back-inner-border: rgba(191, 219, 254, 0.9);

      --card-hearts-split: #dc2626;
      --card-diamonds-split: #dc2626;
      --card-spades-split: #111827;
      --card-clubs-split: #111827;

      --card-hearts-multi: #dc2626;
      --card-diamonds-multi: #ce7c00;
      --card-spades-multi: #1d4ed8;
      --card-clubs-multi: #16a34a;

      --shadow-strong: rgba(0, 0, 0, 0.6);
      --shadow-soft: rgba(0, 0, 0, 0.3);
      --shadow-card: rgba(0, 0, 0, 0.1);
      --pip-shadow: 0 0 0px rgba(0, 0, 0, 0.5);

      --pile-bg-main: #08240c;
      --pile-bg-highlight: #155080;
      --pile-stock-waste-bg: rgba(10, 82, 28, 0.404);
      --pile-inner-border: rgba(6, 78, 66, 0.9);
    }

    body.theme-midnight {
      --accent-primary: #a855f7;
      --accent-primary-soft: rgba(168, 85, 247, 0.22);
      --accent-primary-strong: rgba(168, 85, 247, 0.85);

      --accent-secondary: #4f46e5;
      --accent-secondary-soft: rgba(79, 70, 229, 0.26);
      --accent-secondary-strong: rgba(79, 70, 229, 0.9);

      --bg-gradient-top: #1c0536;
      --bg-gradient-mid: #0b021a;
      --bg-gradient-bottom: #04000a;

      --bg-panel: #050017;
      --bg-panel-alt: #0b0220;

      --border-soft: rgba(139, 92, 246, 0.4);
      --border-strong: rgba(139, 92, 246, 0.8);
      --border-outer-strong: rgba(30, 64, 175, 0.9);

      --text-primary: #e5e7eb;
      --text-muted: #9ca3af;
      --text-on-accent: #f9fafb;
      --text-win: #a855f7;

      --card-front-top: #020617;
      --card-front-bottom: #020617;

      --card-back-base: #1e1b4b;
      --card-back-glow: #4c1d95;
      --card-back-border: #4c1d95;
      --card-back-inner-border: rgba(165, 180, 252, 0.9);

      --card-hearts-split: #fb7185;
      --card-diamonds-split: #fb7185;
      --card-spades-split: #a5b4fc;
      --card-clubs-split: #a5b4fc;

      --card-hearts-multi: #fb7185;
      --card-diamonds-multi: #f97316;
      --card-spades-multi: #5b92d1;
      --card-clubs-multi: #b09fec;

      --shadow-strong: rgba(0, 0, 0, 0.9);
      --shadow-soft: rgba(15, 23, 42, 0.7);
      --shadow-card: rgba(15, 23, 42, 0.8);
      --pip-shadow: 0 0 4px rgba(15, 23, 42, 0.9);

      --pile-bg-main: #020617;
      --pile-bg-highlight: #020617;
      --pile-stock-waste-bg: #020617;
      --pile-inner-border: rgba(15, 23, 42, 0.9);
    }

    body.theme-sunset {
      --accent-primary: #f97316;
      --accent-primary-soft: rgba(249, 115, 22, 0.18);
      --accent-primary-strong: rgba(249, 115, 22, 0.85);

      --accent-secondary: #ec4899;
      --accent-secondary-soft: rgba(236, 72, 153, 0.22);
      --accent-secondary-strong: rgba(236, 72, 153, 0.85);

      --bg-gradient-top: #451a03;
      --bg-gradient-mid: #7c2d12;
      --bg-gradient-bottom: #312e81;

      --bg-panel: #0b1120;
      --bg-panel-alt: #111827;

      --border-soft: rgba(248, 250, 252, 0.25);
      --border-strong: rgba(248, 250, 252, 0.4);
      --border-outer-strong: rgba(15, 23, 42, 0.95);

      --text-primary: #f9fafb;
      --text-muted: #e5e7eb;
      --text-on-accent: #0f172a;
      --text-win: var(--text-primary);

      --card-front-top: #111827;
      --card-front-bottom: #111827;

      --card-back-base: #7c2d12;
      --card-back-glow: #f97316;
      --card-back-border: #ea580c;
      --card-back-inner-border: rgba(254, 215, 170, 0.9);

      --card-hearts-split: var(--accent-primary);
      --card-diamonds-split: var(--accent-primary);
      --card-spades-split: #f9fafb;
      --card-clubs-split: #f9fafb;

      --card-hearts-multi: #fb7185;
      --card-diamonds-multi: var(--accent-primary);
      --card-spades-multi: #e5e7eb;
      --card-clubs-multi: #79d5e4;

      --shadow-strong: rgba(0, 0, 0, 0.9);
      --shadow-soft: rgba(15, 23, 42, 0.8);
      --shadow-card: rgba(15, 23, 42, 0.85);
      --pip-shadow: 0 0 4px rgba(15, 23, 42, 0.9);

      --pile-bg-main: #111827;
      --pile-bg-highlight: #1f2937;
      --pile-stock-waste-bg: #111827;
      --pile-inner-border: rgba(15, 23, 42, 0.9);
    }

    body.theme-pink {
      --accent-primary: #f472b6;
      --accent-primary-soft: rgba(53, 47, 34, 0.4);
      --accent-primary-strong: rgba(244, 114, 182, 0.95);

      --accent-secondary: #fb7185;
      --accent-secondary-soft: rgba(206, 123, 135, 0.24);
      --accent-secondary-strong: rgba(251, 113, 133, 0.95);

      --bg-gradient-top: #fff8eb;
      --bg-gradient-mid: #ffeafa;
      --bg-gradient-bottom: #fffcf2;
      --bg-panel-alt: #f472b6;
      --bg-panel: #ffa1d5;

      --border-soft: rgba(248, 187, 208, 0.8);
      --border-strong: rgba(249, 168, 212, 0.0);
      --border-outer-strong: rgba(255, 93, 187, 0.5);
      --text-primary: #fdf2f8;
      --text-muted: #fecdd3;
      --text-on-accent: #3b0764;
      --text-win: rgb(255, 255, 255);

      --card-front-top: #fff8eb;
      --card-front-bottom: #fffcf2;

      --card-back-base: #f05092d5;
      --card-back-glow: rgba(46, 36, 28, 0.5);
      --card-back-border: #f9a8d4;
      --card-back-inner-border: rgba(244, 114, 182, 0.85);

      --card-hearts-split: #db2777;
      --card-diamonds-split: #db2777;
      --card-spades-split: #111827;
      --card-clubs-split: #111827;

      --card-hearts-multi: #f472b6;
      --card-diamonds-multi: #db2777;
      --card-spades-multi: #111827;
      --card-clubs-multi: #635f4b;

      --shadow-strong: rgba(148, 27, 74, 0.45);
      --shadow-soft: rgba(148, 27, 74, 0.25);
      --shadow-card: rgba(148, 27, 74, 0.15);
      --pip-shadow: 0 0px 0px rgba(148, 27, 74, 0.6);

      --pile-bg-main: rgba(255, 231, 244, 0.96);
      --pile-bg-highlight: rgba(255, 241, 247, 0.7);
      --pile-stock-waste-bg: rgba(255, 231, 244, 0.25);
      --pile-inner-border: rgba(248, 187, 208, 0.3);
      }

    body.theme-ashen {
      --accent-primary: #ef4444;
      --accent-primary-soft: rgba(239, 68, 68, 0.22);
      --accent-primary-strong: rgba(239, 68, 68, 0.9);

      --accent-secondary: #f97316;
      --accent-secondary-soft: rgba(249, 115, 22, 0.18);
      --accent-secondary-strong: rgba(249, 115, 22, 0.9);

      --bg-gradient-top: #020617;
      --bg-gradient-mid: #111827;
      --bg-gradient-bottom: #020617;

      --bg-panel: #020617;
      --bg-panel-alt: #020617;

      --border-soft: rgba(148, 163, 184, 0.5);
      --border-strong: rgba(248, 250, 252, 0.65);
      --border-outer-strong: rgba(15, 23, 42, 0.95);

      --text-primary: #f9fafb;
      --text-muted: #9ca3af;
      --text-on-accent: #f9fafb;
      --text-win: #f97316;

      --card-front-top: #020617;
      --card-front-bottom: #111827;

      --card-back-base: #111827;
      --card-back-glow: #ef4444;
      --card-back-border: #b91c1c;
      --card-back-inner-border: rgba(248, 250, 252, 0.8);

      --card-hearts-split: #ef4444;
      --card-diamonds-split: #ef4444;
      --card-spades-split: #e5e7eb;
      --card-clubs-split: #e5e7eb;

      --card-hearts-multi: #ef4444;
      --card-diamonds-multi: #f97316;
      --card-spades-multi: #9ca3af;
      --card-clubs-multi: #e5e7eb;

      --shadow-strong: rgba(0, 0, 0, 0.9);
      --shadow-soft: rgba(15, 23, 42, 0.8);
      --shadow-card: rgba(15, 23, 42, 0.85);
      --pip-shadow: 0 0 3px rgba(0, 0, 0, 0.75);

      --pile-bg-main: #020617;
      --pile-bg-highlight: #111827;
      --pile-stock-waste-bg: #020617;
      --pile-inner-border: rgba(15, 23, 42, 0.9);
    }

    * {
      box-sizing: border-box;
      user-select: none;
    }

    body {
      margin: 0;
      padding: 0;
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background:
        radial-gradient(circle at top, var(--bg-gradient-top) 0%, var(--bg-gradient-mid) 45%, var(--bg-gradient-bottom) 100%);
      color: var(--text-primary);
    }

    .game {
      width: min(880px, 100vw - 40px);
      height: min(750px, 100vh - 40px);
      background:
        radial-gradient(circle at 0 0, var(--accent-primary-soft), transparent 55%),
        linear-gradient(145deg, var(--bg-panel-alt), var(--bg-panel));
      border-radius: 18px;
      padding: 16px 18px 18px;
      display: flex;
      flex-direction: column;
      box-shadow:
        0 22px 55px var(--shadow-strong),
        0 0 0 1px var(--border-outer-strong);
      border: 1px solid var(--border-soft);
      overflow: auto;
      touch-action: none;
    }

    .top-bar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 10px;
      gap: 10px;
    }

    #status {
      font-size: 20px;
      min-height: 1em;
      color: var(--text-win);
      text-shadow: 0 0 8px var(--accent-primary-soft);
      flex: 1;
      text-align: center;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .top-bar-actions {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-shrink: 0;
    }

    #undo-button {
      visibility: hidden;
    }

    #undo-button .icon {
      font-size: 16px;
    }

    .theme-switcher {
      position: relative;
    }

    .pip-mode-switcher {
      position: relative;
    }

    .chip-button {
      border: 1px solid rgba(0, 0, 0, 0.3);
      border-radius: 999px;
      padding: 8px 16px;
      font-size: 14px;
      background: rgba(0, 0, 0, 0.3);
      color: whitesmoke;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      white-space: nowrap;
    }

    .chip-button:hover {
      border-color: grey;
      text: white;
    }

    .chip-button-label {
      text-transform: uppercase;
      letter-spacing: 0.08em;
      font-size: 10px;
      color: lightgrey;
    }

    #theme-toggle .theme-name,
    #pip-toggle .pip-mode-name {
      border-color: whitesmoke;
      color: whitesmoke;
    }

    .theme-caret {
      font-size: 10px;
      margin-left: 2px;
      opacity: 0.8;
    }

    .theme-menu {
      position: absolute;
      right: 0;
      top: calc(100% + 6px);
      min-width: 190px;
      padding: 4px;
      border-radius: 10px;
      border: 1px solid darkgrey;
      background: rgba(0, 0, 0, 0.9);
      display: none;
      z-index: 1000;
    }

    .theme-menu.open {
      display: block;
    }

    .theme-option {
      width: 100%;
      text-align: left;
      border: none;
      background: transparent;
      color: var(--text-primary);
      font-size: 14px;
      padding: 8px 16px;
      border-radius: 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .theme-option:hover {
      background: rgba(148, 163, 184, 0.14);
    }

    .theme-option.active {
      background: var(--accent-primary-soft);
      color: var(--accent-primary);
    }

    .theme-option-dot {
      width: 10px;
      height: 10px;
      border-radius: 999px;
      border: 1px solid var(--border-soft);
      flex-shrink: 0;
    }

    #new-game {
      border: 1px solid rgba(0, 0, 0, 0.3);
      border-radius: 999px;
      padding: 8px 16px;
      font-size: 14px;
      background: rgba(0, 0, 0, 0.3);
      color: whitesmoke;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      white-space: nowrap;
    }

    #new-game:hover {
      border-color: grey;
      text: white;
    }

    #new-game:active {
      transform: translateY(0);
    }

    #new-game span.icon {
      font-size: 16px;
    }

    .table {
      flex: 1;
      display: flex;
      flex-direction: column;
      margin-top: 4px;
      align-items: center;
    }

    .top-row,
    .tableau-row {
      width: 100%;
      max-width: calc(7 * var(--card-width) + 6 * var(--pile-gap));
      margin: 0 auto;
    }

    .top-row {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 18px;
      gap: var(--pile-gap);
    }

    .left-top,
    .right-top {
      display: flex;
      align-items: flex-start;
      gap: var(--pile-gap);
    }

    .right-top {
      margin-left: auto;
    }

    .pile {
      width: var(--card-width);
      height: var(--card-height);
      border-radius: 10px;
      border: 1px dashed var(--border-soft);
      position: relative;
      flex-shrink: 0;
      background: radial-gradient(circle at top, var(--pile-bg-highlight), var(--pile-bg-main));
      box-shadow:
        inset 0 0 0 1px var(--pile-inner-border),
        0 4px 8px var(--shadow-soft);
    }

    .pile.stock,
    .pile.waste {
      border-style: solid;
      border-color: var(--border-strong);
      background:
        radial-gradient(circle at 30% 0, var(--accent-secondary-soft), var(--pile-stock-waste-bg));
    }

    .pile.stock.empty {
      border-style: dashed;
      border-color: var(--border-soft);
      background: transparent;
      box-shadow: inset 0 0 0 1px var(--pile-inner-border);
    }

    .pile.foundation,
    .pile.tableau-pile {
      background:
        radial-gradient(circle at 0 0, var(--accent-primary-soft), rgba(15, 23, 42, 0.4));
    }

    .pile.foundation::before {
      content: attr(data-suit);
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 30px;
      opacity: 0.2;
      pointer-events: none;
      color: var(--text-muted);
    }

    .pile.foundation.has-cards::before {
      display: none;
    }

    .tableau-row {
      display: flex;
      gap: var(--pile-gap);
      align-items: flex-start;
      flex: 1;
      padding-top: 4px;
    }

    .pile.tableau-pile {
      flex: 0 0 auto;
    }

    .card {
      position: absolute;
      width: var(--card-width);
      height: var(--card-height);
      border-radius: 6px;
      box-shadow:
        0 10px 20px var(--shadow-card),
        0 0 0 1px var(--border-outer-strong);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: grab;
      transition: transform var(--transition-fast), box-shadow var(--transition-fast);
      transform-origin: center center;
    }

    .card:active {
      cursor: grabbing;
    }

    .card-back {
      background:
        radial-gradient(circle at 20% 20%, var(--card-back-glow), rgba(15, 23, 42, 0.7)),
        linear-gradient(145deg, var(--card-back-base), var(--card-back-base));
      overflow: hidden;
    }

    .card-back::before {
      content: "";
      position: absolute;
      opacity: 0.9;
    }

    .card-front {
      border: 1px solid var(--border-strong);
      background: linear-gradient(180deg, var(--card-front-top), var(--card-front-top) 40%, var(--card-front-bottom) 100%);
      color: var(--text-primary);
    }

    .card.red.hearts {
      color: var(--card-hearts);
    }

    .card.red.diamonds {
      color: var(--card-diamonds);
    }

    .card.black.spades {
      color: var(--card-spades);
    }

    .card.black.clubs {
      color: var(--card-clubs);
    }

    .card .corner {
      position: absolute;
      font-size: 19px;
      line-height: 1.1;
      text-align: center;
      font-weight: 700;
      text-shadow: var(--pip-shadow);
    }

    .card .corner.top-left {
      top: 5px;
      left: 6px;
    }

    .card .corner.bottom-right {
      bottom: 5px;
      right: 6px;
      transform: rotate(180deg);
    }

    .card .corner span.rank {
      display: block;
      font-size: 21px;
      margin-bottom: 1px;
    }

    .card .corner span.suit {
      display: block;
      font-size: 21px;
    }

    .card .pip {
      font-size: 30px;
      opacity: 0.22;
    }

    .card.is-dragging {
      opacity: 0;
    }

    .drag-layer {
      position: fixed;
      pointer-events: none;
      z-index: 999;
    }

    .pile.highlight {
      box-shadow:
        0 0 0 3px var(--accent-primary-strong),
        0 0 25px var(--accent-primary-soft);
      border-color: var(--accent-primary-strong);
    }

    .pile.waste {
      width: calc(var(--card-width) + 2 * var(--waste-gap));
    }

    .pile.waste .card {
      transform: translateX(0);
    }

    #undo-button-text {
      display: block;
    }

    @media (max-width: 900px) {
      html,
      body {
        margin: 0;
        padding: 0;
        height: 100dvh;
        overflow: hidden;
      }

      body {
        display: block;
        background: none;
      }

      :root {
        --safe-width: calc(100vw - 36px);
        --card-width: calc(var(--safe-width) / 8.05);
        --card-height: calc(var(--card-width) * 1.5);
        --pile-gap: calc(var(--card-width) * 0.175);
        --tableau-offset-faceup: calc(var(--card-height) * 0.267);
        --tableau-offset-facedown: calc(var(--card-height) * 0.1);
        --waste-gap: calc(var(--card-width) * 0.5);
      }

      .game {
        width: 100vw;
        height: 100dvh;
        border-radius: 0;
        margin: 0;
        box-shadow: none;
        border: none;
      }

      .top-row,
      .tableau-row {
        max-width: none;
      }

      #status {
        font-size: 14px;
      }

      .card {
        box-shadow:
          0 4px 10px var(--shadow-card),
          0 0 0 1px var(--border-outer-strong);
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: grab;
        transition: transform var(--transition-fast), box-shadow var(--transition-fast);
        transform-origin: center center;
      }

      .card .pip {
        font-size: calc(var(--card-width) * 0.3);
        opacity: 0.22;
      }

      .card .corner span.rank {
        display: block;
        font-size: calc(var(--card-width) * 0.25);
        margin-bottom: 1px;
      }

      .card .corner span.suit {
        display: block;
        font-size: calc(var(--card-width) * 0.25);
      }

      .card-back {
        background:
          radial-gradient(circle at 20% 20%, var(--card-back-glow), rgba(15, 23, 42, 0.7)),
          linear-gradient(145deg, var(--card-back-base), var(--card-back-base));
        overflow: hidden;
      }

      .pile.foundation::before {
        content: attr(data-suit);
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 22px;
        opacity: 0.2;
        pointer-events: none;
        color: var(--text-muted);
      }

      #undo-button {
        padding: 6px 12px;
      }

      #undo-button-text {
        display: none;
      }

      .chip-button-label {
        display: none;
      }

      .chip-button {
        padding: 10px 12px;
        font-size: 10px;
      }

      #new-game {
        padding: 6px 12px;
        font-size: 10px;
      }

      .top-bar {
        gap: 4px;
      }

      .top-bar-actions {
        gap: 4px;
      }
    }
  </style>
</head>
<body>
  <div class="game">
    <div class="top-bar">
      <button id="undo-button" type="button" class="chip-button">
        <span id="undo-icon" class="icon">⟲</span>
        <span id="undo-button-text">Undo</span>
      </button>

      <div id="status"></div>

      <div class="top-bar-actions">
        <div class="pip-mode-switcher">
          <button id="pip-toggle" type="button" class="chip-button" aria-pressed="false">
            <span class="chip-button-label">Pips</span>
            <span class="pip-mode-name" id="current-pip-mode">Split</span>
          </button>
        </div>

        <div class="theme-switcher">
          <button id="theme-toggle" type="button" class="chip-button" aria-haspopup="true" aria-expanded="false">
            <span class="chip-button-label">Theme</span>
            <span class="theme-name" id="current-theme-name">Neon Night</span>
            <span class="theme-caret">▾</span>
          </button>
          <div id="theme-menu" class="theme-menu" role="menu" aria-label="Select theme">
          </div>
        </div>

        <button id="new-game">
          <span class="icon">↻</span>
          <span>New game</span>
        </button>
      </div>
    </div>

    <div class="table">
      <div class="top-row">
        <div class="left-top">
          <div class="pile stock empty" id="stock" data-pile-type="stock"></div>
          <div class="pile waste" id="waste" data-pile-type="waste"></div>
        </div>

        <div class="right-top">
          <div class="pile foundation" data-pile-type="foundation" data-foundation-index="0" data-suit="♠"></div>
          <div class="pile foundation" data-pile-type="foundation" data-foundation-index="1" data-suit="♥"></div>
          <div class="pile foundation" data-pile-type="foundation" data-foundation-index="2" data-suit="♦"></div>
          <div class="pile foundation" data-pile-type="foundation" data-foundation-index="3" data-suit="♣"></div>
        </div>
      </div>

      <div class="tableau-row">
        <div class="pile tableau-pile" data-pile-type="tableau" data-pile-index="0"></div>
        <div class="pile tableau-pile" data-pile-type="tableau" data-pile-index="1"></div>
        <div class="pile tableau-pile" data-pile-type="tableau" data-pile-index="2"></div>
        <div class="pile tableau-pile" data-pile-type="tableau" data-pile-index="3"></div>
        <div class="pile tableau-pile" data-pile-type="tableau" data-pile-index="4"></div>
        <div class="pile tableau-pile" data-pile-type="tableau" data-pile-index="5"></div>
        <div class="pile tableau-pile" data-pile-type="tableau" data-pile-index="6"></div>
      </div>
    </div>
  </div>

  <script>
    const SUITS = ["♠", "♥", "♦", "♣"];
    const RANK_LABELS = {
      1: "A",
      11: "J",
      12: "Q",
      13: "K"
    };

    const THEMES = [
      { id: "neon", name: "Midnight", preview: "#14489c" },
      { id: "sunset", name: "Sunset", preview: "#f97316" },
      { id: "classic", name: "Casino", preview: "#16a34a" },
      { id: "pink", name: "Cherry", preview: "#ec4899" },
      { id: "ashen", name: "Ember", preview: "#b91c1c" },
      { id: "midnight", name: "Purple", preview: "#a855f7" },
    ];

    const THEME_STORAGE_KEY = "solitaire-theme";
    const PIP_STORAGE_KEY = "solitaire-pip-mode";

    let stock = [];
    let waste = [];
    let wasteDrawStart = 0;
    let foundations = [[], [], [], []];
    let tableau = [[], [], [], [], [], [], []];

    let dragState = null;
    let pendingDrag = null;
    let previousState = null;

    let stockEl, wasteEl, foundationEls, tableauEls, statusEl, newGameBtn, undoButton;
    let themeToggleBtn, themeMenuEl, currentThemeNameEl;
    let pipToggleBtn, currentPipModeLabel;

    let activeTouch = null;
    let lastTapTime = 0;
    let lastTapCardId = null;
    let lastTapX = 0;
    let lastTapY = 0;
    const DOUBLE_TAP_DELAY = 200;
    const DOUBLE_TAP_DISTANCE = 25;

    window.addEventListener("DOMContentLoaded", () => {
      stockEl = document.getElementById("stock");
      wasteEl = document.getElementById("waste");
      foundationEls = document.querySelectorAll(".foundation");
      tableauEls = document.querySelectorAll(".tableau-pile");
      statusEl = document.getElementById("status");
      newGameBtn = document.getElementById("new-game");
      undoButton = document.getElementById("undo-button");

      themeToggleBtn = document.getElementById("theme-toggle");
      themeMenuEl = document.getElementById("theme-menu");
      currentThemeNameEl = document.getElementById("current-theme-name");

      pipToggleBtn = document.getElementById("pip-toggle");
      currentPipModeLabel = document.getElementById("current-pip-mode");

      newGameBtn.addEventListener("click", startNewGame);
      stockEl.addEventListener("click", onStockClick);
      if (undoButton) {
        undoButton.addEventListener("click", onUndoClick);
      }

      stockEl.addEventListener("touchstart", onStockTouchStart, { passive: false });
      newGameBtn.addEventListener("touchstart", onButtonTouchStart, { passive: false });
      if (undoButton) {
        undoButton.addEventListener("touchstart", onButtonTouchStart, { passive: false });
      }
      if (pipToggleBtn) {
        pipToggleBtn.addEventListener("touchstart", onButtonTouchStart, { passive: false });
      }
      if (themeToggleBtn) {
        themeToggleBtn.addEventListener("touchstart", onButtonTouchStart, { passive: false });
      }

      document.addEventListener("mousemove", onMouseMove);
      document.addEventListener("mouseup", onMouseUp);
      document.addEventListener("touchmove", onTouchMove, { passive: false });
      document.addEventListener("touchend", onTouchEnd, { passive: false });
      document.addEventListener("touchcancel", onTouchEnd, { passive: false });

      initThemeSystem();
      initPipModeSystem();
      updateUndoButtonVisibility();
      startNewGame();

      window.addEventListener("resize", () => {
        if (dragState || pendingDrag) return;
        render();
      });
    });

    function initThemeSystem() {
      if (!themeToggleBtn || !themeMenuEl) return;

      themeMenuEl.innerHTML = "";
      THEMES.forEach((theme) => {
        const btn = document.createElement("button");
        btn.type = "button";
        btn.className = "theme-option";
        btn.dataset.themeId = theme.id;
        btn.setAttribute("role", "menuitem");

        const labelSpan = document.createElement("span");
        labelSpan.textContent = theme.name;

        const dotSpan = document.createElement("span");
        dotSpan.className = "theme-option-dot";
        if (theme.preview) {
          dotSpan.style.backgroundColor = theme.preview;
        }

        btn.appendChild(labelSpan);
        btn.appendChild(dotSpan);

        btn.addEventListener("click", (e) => {
          e.stopPropagation();
          applyTheme(theme.id);
          closeThemeMenu();
        });
        btn.addEventListener("touchstart", onButtonTouchStart, { passive: false });

        themeMenuEl.appendChild(btn);
      });

      themeToggleBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        const isOpen = themeMenuEl.classList.toggle("open");
        themeToggleBtn.setAttribute("aria-expanded", isOpen ? "true" : "false");
      });

      themeMenuEl.addEventListener("click", (e) => {
        e.stopPropagation();
      });

      document.addEventListener("click", () => {
        closeThemeMenu();
      });

      document.addEventListener("keydown", (e) => {
        if (e.key === "Escape") {
          closeThemeMenu();
        }
      });

      let saved = null;
      try {
        saved = localStorage.getItem(THEME_STORAGE_KEY);
      } catch (err) {
        saved = null;
      }
      const initialId = THEMES.some((t) => t.id === saved) ? saved : "neon";
      applyTheme(initialId);
    }

    function closeThemeMenu() {
      if (!themeMenuEl || !themeToggleBtn) return;
      if (!themeMenuEl.classList.contains("open")) return;
      themeMenuEl.classList.remove("open");
      themeToggleBtn.setAttribute("aria-expanded", "false");
    }

    function applyTheme(themeId) {
      const theme = THEMES.find((t) => t.id === themeId) || THEMES[0];
      const body = document.body;

      THEMES.forEach((t) => {
        body.classList.remove(`theme-${t.id}`);
      });
      if (theme.id !== "neon") {
        body.classList.add(`theme-${theme.id}`);
      }

      if (currentThemeNameEl) {
        currentThemeNameEl.textContent = theme.name;
      }

      if (themeMenuEl) {
        const options = themeMenuEl.querySelectorAll(".theme-option");
        options.forEach((option) => {
          if (option.dataset.themeId === theme.id) {
            option.classList.add("active");
          } else {
            option.classList.remove("active");
          }
        });
      }

      try {
        localStorage.setItem(THEME_STORAGE_KEY, theme.id);
      } catch (err) {
      }
    }

    function initPipModeSystem() {
      if (!pipToggleBtn || !currentPipModeLabel) return;

      let savedMode = null;
      try {
        savedMode = localStorage.getItem(PIP_STORAGE_KEY);
      } catch (err) {
        savedMode = null;
      }

      const initial = (savedMode === "multi" || savedMode === "split") ? savedMode : "split";
      setPipMode(initial);

      pipToggleBtn.addEventListener("click", () => {
        const multiNow = document.body.classList.contains("pips-multi");
        setPipMode(multiNow ? "split" : "multi");
      });
    }

    function setPipMode(mode) {
      const body = document.body;
      body.classList.remove("pips-split", "pips-multi");

      if (mode === "multi") {
        body.classList.add("pips-multi");
        currentPipModeLabel.textContent = "Multi";
      } else {
        mode = "split";
        body.classList.add("pips-split");
        currentPipModeLabel.textContent = "Split";
      }

      if (pipToggleBtn) {
        pipToggleBtn.setAttribute("aria-pressed", mode === "multi" ? "true" : "false");
      }

      try {
        localStorage.setItem(PIP_STORAGE_KEY, mode);
      } catch (err) {
      }
    }

    function cloneCard(card) {
      return { ...card };
    }

    function clonePile(pile) {
      return pile.map(cloneCard);
    }

    function saveStateForUndo() {
      previousState = {
        stock: clonePile(stock),
        waste: clonePile(waste),
        wasteDrawStart,
        foundations: foundations.map(clonePile),
        tableau: tableau.map(clonePile),
        statusText: statusEl ? statusEl.textContent : ""
      };
      updateUndoButtonVisibility();
    }

    function restoreStateFromUndo() {
      if (!previousState) return;
      stock = clonePile(previousState.stock);
      waste = clonePile(previousState.waste);
      wasteDrawStart = previousState.wasteDrawStart;
      foundations = previousState.foundations.map(clonePile);
      tableau = previousState.tableau.map(clonePile);
      if (statusEl) {
        statusEl.textContent = previousState.statusText || "";
      }
    }

    function updateUndoButtonVisibility() {
      if (!undoButton) return;
      undoButton.style.visibility = previousState ? "visible" : "hidden";
    }

    function onUndoClick() {
      if (!previousState) return;
      restoreStateFromUndo();
      previousState = null;
      dragState = null;
      pendingDrag = null;
      updateUndoButtonVisibility();
      render();
    }

    function createDeck() {
      const deck = [];
      for (let s = 0; s < 4; s++) {
        for (let r = 1; r <= 13; r++) {
          deck.push({
            id: `${s}-${r}-${Math.random().toString(36).slice(2, 7)}`,
            suitIndex: s,
            suit: SUITS[s],
            rank: r,
            color: s === 1 || s === 2 ? "red" : "black",
            faceUp: false
          });
        }
      }
      return deck;
    }

    function shuffle(array) {
      const a = array.slice();
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    function startNewGame() {
      const deck = shuffle(createDeck());
      stock = [];
      waste = [];
      wasteDrawStart = 0;
      foundations = [[], [], [], []];
      tableau = [[], [], [], [], [], [], []];
      dragState = null;
      pendingDrag = null;
      previousState = null;
      statusEl.textContent = "You win!";

      let index = 0;
      for (let col = 0; col < 7; col++) {
        for (let row = 0; row <= col; row++) {
          const card = deck[index++];
          card.faceUp = row === col;
          tableau[col].push(card);
        }
      }

      while (index < deck.length) {
        const card = deck[index++];
        card.faceUp = false;
        stock.push(card);
      }

      render();
      updateUndoButtonVisibility();
    }

    function render() {
      renderStock();
      renderWaste();
      renderFoundations();
      renderTableau();
    }

    function createCardElement(card) {
      const el = document.createElement("div");
      el.classList.add("card");
      if (!card.faceUp) {
        el.classList.add("card-back");
      } else {
        el.classList.add("card-front");
        if (card.color === "red") {
          el.classList.add("red");
          el.classList.add(card.suit === "♥" ? "hearts" : "diamonds");
        } else {
          el.classList.add("black");
          el.classList.add(card.suit === "♣" ? "clubs" : "spades");
        }
        const rankLabel = RANK_LABELS[card.rank] || String(card.rank);
        const topCorner = document.createElement("div");
        topCorner.classList.add("corner", "top-left");
        topCorner.innerHTML = `<span class="rank">${rankLabel}</span><span class="suit">${card.suit}</span>`;

        const bottomCorner = document.createElement("div");
        bottomCorner.classList.add("corner", "bottom-right");
        bottomCorner.innerHTML = `<span class="rank">${rankLabel}</span><span class="suit">${card.suit}</span>`;

        const pip = document.createElement("div");
        pip.classList.add("pip");
        pip.textContent = card.suit;

        el.appendChild(topCorner);
        el.appendChild(bottomCorner);
      }

      el.dataset.cardId = card.id;
      el.addEventListener("mousedown", onCardMouseDown);
      el.addEventListener("dblclick", onCardDoubleClick);
      if (card.faceUp) {
        el.addEventListener("touchstart", onCardTouchStart, { passive: false });
      }

      return el;
    }

    function getCssVarPx(varName, fallback) {
      const probe = document.createElement("div");
      probe.style.position = "absolute";
      probe.style.visibility = "hidden";
      probe.style.height = `var(${varName})`;
      document.body.appendChild(probe);

      const value = parseFloat(getComputedStyle(probe).height);
      document.body.removeChild(probe);

      if (Number.isNaN(value)) {
        return fallback;
      }
      return value;
    }

    function renderStock() {
      stockEl.innerHTML = "";
      stockEl.classList.toggle("empty", stock.length === 0);

      if (stock.length > 0) {
        const card = stock[stock.length - 1];
        card.faceUp = false;
        const cardEl = createCardElement(card);
        cardEl.dataset.pileType = "stock";
        cardEl.dataset.pileIndex = "-1";
        cardEl.dataset.cardIndex = String(stock.length - 1);
        cardEl.style.top = "0px";
        stockEl.appendChild(cardEl);
      }
    }

    function renderWaste() {
      wasteEl.innerHTML = "";

      const available = waste.length - wasteDrawStart;
      if (available <= 0) {
        return;
      }

      const visibleCount = Math.min(3, available);
      const start = waste.length - visibleCount;

      const gap = getCssVarPx("--waste-gap", 16);

      for (let i = start; i < waste.length; i++) {
        const card = waste[i];
        const cardEl = createCardElement(card);
        cardEl.dataset.pileType = "waste";
        cardEl.dataset.pileIndex = "0";
        cardEl.dataset.cardIndex = String(i);
        const offset = (i - start) * gap;
        cardEl.style.left = `${offset}px`;
        cardEl.style.top = "0px";
        cardEl.style.zIndex = String(i);
        wasteEl.appendChild(cardEl);
      }
    }

    function renderFoundations() {
      foundationEls.forEach((pileEl, i) => {
        pileEl.innerHTML = "";
        const pile = foundations[i];
        if (pile.length > 0) {
          pileEl.classList.add("has-cards");
        } else {
          pileEl.classList.remove("has-cards");
        }

        pile.forEach((card, index) => {
          const cardEl = createCardElement(card);
          cardEl.dataset.pileType = "foundation";
          cardEl.dataset.foundationIndex = String(i);
          cardEl.dataset.cardIndex = String(index);
          cardEl.style.top = "0px";
          pileEl.appendChild(cardEl);
        });
      });
    }

    function renderTableau() {
      const faceDownOffset = getCssVarPx("--tableau-offset-facedown", 12);
      const faceUpOffset = getCssVarPx("--tableau-offset-faceup", 26);

      tableauEls.forEach((pileEl, i) => {
        pileEl.innerHTML = "";
        const pile = tableau[i];

        let y = 0;
        pile.forEach((card, index) => {
          const cardEl = createCardElement(card);
          cardEl.dataset.pileType = "tableau";
          cardEl.dataset.pileIndex = String(i);
          cardEl.dataset.cardIndex = String(index);
          cardEl.style.top = `${y}px`;
          cardEl.style.zIndex = String(index);
          pileEl.appendChild(cardEl);

          y += card.faceUp ? faceUpOffset : faceDownOffset;
        });
      });
    }

    function onStockClick() {
      if (dragState || pendingDrag) return;

      if (stock.length === 0) {
        if (waste.length === 0) return;
        saveStateForUndo();
        while (waste.length > 0) {
          const card = waste.pop();
          card.faceUp = false;
          stock.push(card);
        }
        wasteDrawStart = 0;
      } else {
        saveStateForUndo();
        const drawCount = Math.min(3, stock.length);
        for (let i = 0; i < drawCount; i++) {
          const card = stock.pop();
          card.faceUp = true;
          waste.push(card);
        }
        wasteDrawStart = waste.length - drawCount;
      }
      render();
    }

    function onStockTouchStart(e) {
      if (e.touches.length > 1) return;
      e.preventDefault();
      onStockClick();
    }

    function onButtonTouchStart(e) {
      if (e.touches.length > 1) return;
      e.preventDefault();
      e.currentTarget.click();
    }

    function onCardMouseDown(e) {
      if (e.button !== 0) return;
      e.preventDefault();

      const cardEl = e.currentTarget;
      const pileType = cardEl.dataset.pileType;
      const pileIndex = parseInt(cardEl.dataset.pileIndex, 10);
      const cardIndex = parseInt(cardEl.dataset.cardIndex, 10);

      let cardsToDrag = [];
      let from = null;

      if (pileType === "tableau") {
        const pile = tableau[pileIndex];
        const card = pile[cardIndex];
        if (!card || !card.faceUp) return;
        cardsToDrag = pile.slice(cardIndex);
        from = { type: "tableau", pileIndex, startIndex: cardIndex };
      } else if (pileType === "waste") {
        if (cardIndex !== waste.length - 1) return;
        cardsToDrag = [waste[cardIndex]];
        from = { type: "waste", pileIndex: 0, startIndex: cardIndex };
      } else if (pileType === "foundation") {
        const pile = foundations[parseInt(cardEl.dataset.foundationIndex, 10)];
        if (cardIndex !== pile.length - 1) return;
        cardsToDrag = [pile[cardIndex]];
        from = {
          type: "foundation",
          pileIndex: parseInt(cardEl.dataset.foundationIndex, 10),
          startIndex: cardIndex
        };
      } else {
        return;
      }

      pendingDrag = {
        startX: e.clientX,
        startY: e.clientY,
        cardEl,
        cardsToDrag,
        from
      };
    }

    function startDrag(clientX, clientY, cardEl, cardsToDrag, from) {
      const rect = cardEl.getBoundingClientRect();
      const offsetX = clientX - rect.left;
      const offsetY = clientY - rect.top;

      const dragLayer = document.createElement("div");
      dragLayer.classList.add("drag-layer");
      dragLayer.style.left = rect.left + "px";
      dragLayer.style.top = rect.top + "px";
      dragLayer.style.width = rect.width + "px";

      cardsToDrag.forEach((card, index) => {
        const el = createCardElement(card);
        el.style.top = `${index * 26}px`;
        el.style.left = "0px";
        el.style.zIndex = String(index);
        dragLayer.appendChild(el);
      });

      document.body.appendChild(dragLayer);

      const originals = [];
      let node = cardEl;
      while (node) {
        originals.push(node);
        node.classList.add("is-dragging");
        node = node.nextElementSibling;
      }

      dragState = {
        cards: cardsToDrag,
        from,
        offsetX,
        offsetY,
        dragEl: dragLayer,
        originalElements: originals
      };
    }

    function onMouseMove(e) {
      if (dragState) {
        dragState.dragEl.style.left = e.clientX - dragState.offsetX + "px";
        dragState.dragEl.style.top = e.clientY - dragState.offsetY + "px";
        return;
      }

      if (pendingDrag && (e.buttons & 1)) {
        const dx = e.clientX - pendingDrag.startX;
        const dy = e.clientY - pendingDrag.startY;
        if (Math.hypot(dx, dy) > 5) {
          startDrag(
            e.clientX,
            e.clientY,
            pendingDrag.cardEl,
            pendingDrag.cardsToDrag,
            pendingDrag.from
          );
          pendingDrag = null;
        }
      }
    }

    function findDropTargetPile(clientX, clientY) {
      const candidates = Array.from(
        document.querySelectorAll(
          '.pile[data-pile-type="tableau"], .pile[data-pile-type="foundation"]'
        )
      );

      const margin = 40;
      let bestPile = null;
      let bestDist = Infinity;

      for (const pile of candidates) {
        const baseRect = pile.getBoundingClientRect();
        let left = baseRect.left;
        let right = baseRect.right;
        let top = baseRect.top;
        let bottom = baseRect.bottom;

        if (pile.dataset.pileType === "tableau") {
          const cards = pile.querySelectorAll(".card");
          if (cards.length > 0) {
            const lastCardRect = cards[cards.length - 1].getBoundingClientRect();
            top = Math.min(top, lastCardRect.top);
            bottom = Math.max(bottom, lastCardRect.bottom);
            left = Math.min(left, lastCardRect.left);
            right = Math.max(right, lastCardRect.right);
          }
        }

        let dx = 0;
        if (clientX < left) dx = left - clientX;
        else if (clientX > right) dx = clientX - right;

        let dy = 0;
        if (clientY < top) dy = top - clientY;
        else if (clientY > bottom) dy = clientY - bottom;

        const dist = Math.hypot(dx, dy);

        if (dist <= margin && dist < bestDist) {
          bestDist = dist;
          bestPile = pile;
        }
      }

      return bestPile;
    }

    function onMouseUp(e) {
      if (pendingDrag) {
        pendingDrag = null;
      }

      if (!dragState) return;

      const pileEl = findDropTargetPile(e.clientX, e.clientY);

      let moved = false;

      if (pileEl) {
        const pileType = pileEl.dataset.pileType;
        if (pileType === "tableau") {
          const destIndex = parseInt(pileEl.dataset.pileIndex, 10);
          moved = tryMoveToTableau(destIndex);
        } else if (pileType === "foundation") {
          const destIndex = parseInt(pileEl.dataset.foundationIndex, 10);
          moved = tryMoveToFoundation(destIndex);
        }
      }

      if (moved) {
        if (dragState.from.type === "tableau") {
          const srcPile = tableau[dragState.from.pileIndex];
          if (srcPile.length > 0 && !srcPile[srcPile.length - 1].faceUp) {
            srcPile[srcPile.length - 1].faceUp = true;
          }
        }
        checkForWin();
      }

      cleanupDrag();
      render();
    }

    function cleanupDrag() {
      if (!dragState) return;
      dragState.originalElements.forEach((el) => el.classList.remove("is-dragging"));
      if (dragState.dragEl && dragState.dragEl.parentNode) {
        dragState.dragEl.parentNode.removeChild(dragState.dragEl);
      }
      dragState = null;
    }

    function removeCardsFromSource(from, count) {
      if (from.type === "tableau") {
        tableau[from.pileIndex].splice(from.startIndex, count);
      } else if (from.type === "waste") {
        waste.splice(from.startIndex, count);
      } else if (from.type === "foundation") {
        foundations[from.pileIndex].splice(from.startIndex, count);
      }
    }

    function canPlaceOnTableau(card, destPile) {
      if (destPile.length === 0) {
        return card.rank === 13;
      }
      const top = destPile[destPile.length - 1];
      return (
        top.faceUp &&
        card.color !== top.color &&
        card.rank === top.rank - 1
      );
    }

    function canPlaceOnFoundation(card, destPile) {
      if (destPile.length === 0) {
        return card.rank === 1;
      }
      const top = destPile[destPile.length - 1];
      return card.suitIndex === top.suitIndex && card.rank === top.rank + 1;
    }

    function tryMoveToTableau(destIndex) {
      const { cards, from } = dragState;
      const card = cards[0];
      const destPile = tableau[destIndex];

      if (!canPlaceOnTableau(card, destPile)) return false;

      saveStateForUndo();
      removeCardsFromSource(from, cards.length);
      tableau[destIndex] = tableau[destIndex].concat(cards);
      return true;
    }

    function tryMoveToFoundation(destIndex) {
      const { cards, from } = dragState;
      if (cards.length !== 1) return false;
      const card = cards[0];
      const destPile = foundations[destIndex];

      if (!canPlaceOnFoundation(card, destPile)) return false;

      saveStateForUndo();
      removeCardsFromSource(from, 1);
      foundations[destIndex].push(card);
      return true;
    }

    function onCardDoubleClick(e) {
      e.preventDefault();
      e.stopPropagation();

      if (dragState || pendingDrag) return;

      const cardEl = e.currentTarget;
      const pileType = cardEl.dataset.pileType;

      let sourcePile = null;
      let sourceType = null;
      let pileIndex = -1;
      let card = null;

      if (pileType === "tableau") {
        pileIndex = parseInt(cardEl.dataset.pileIndex, 10);
        const cardIndex = parseInt(cardEl.dataset.cardIndex, 10);
        sourcePile = tableau[pileIndex];
        if (!sourcePile || cardIndex !== sourcePile.length - 1) return;
        card = sourcePile[cardIndex];
        sourceType = "tableau";
      } else if (pileType === "waste") {
        const cardIndex = parseInt(cardEl.dataset.cardIndex, 10);
        if (cardIndex !== waste.length - 1) return;
        sourcePile = waste;
        card = waste[cardIndex];
        sourceType = "waste";
      } else {
        return;
      }

      if (!card || !card.faceUp) return;

      for (let i = 0; i < foundations.length; i++) {
        const destPile = foundations[i];
        if (canPlaceOnFoundation(card, destPile)) {
          saveStateForUndo();

          if (sourceType === "tableau") {
            sourcePile.pop();
            const srcPile = tableau[pileIndex];
            if (srcPile.length > 0 && !srcPile[srcPile.length - 1].faceUp) {
              srcPile[srcPile.length - 1].faceUp = true;
            }
          } else if (sourceType === "waste") {
            sourcePile.pop();
          }

          destPile.push(card);
          checkForWin();
          render();
          break;
        }
      }
    }

    function onCardTouchStart(e) {
      if (e.touches.length > 1) return;
      const t = e.touches[0];
      if (!t) return;
      e.preventDefault();
      const cardEl = e.currentTarget;
      const now = Date.now();
      activeTouch = {
        cardEl,
        startTime: now,
        startX: t.clientX,
        startY: t.clientY,
        moved: false
      };
      onCardMouseDown({
        button: 0,
        preventDefault: () => {},
        currentTarget: cardEl,
        clientX: t.clientX,
        clientY: t.clientY
      });
    }

    function onTouchMove(e) {
      if (!activeTouch && !pendingDrag && !dragState) return;
      const t = e.touches[0];
      if (!t) return;
      e.preventDefault();
      if (activeTouch) {
        const dx = t.clientX - activeTouch.startX;
        const dy = t.clientY - activeTouch.startY;
        if (Math.hypot(dx, dy) > 5) {
          activeTouch.moved = true;
        }
      }
      onMouseMove({
        clientX: t.clientX,
        clientY: t.clientY,
        buttons: 1
      });
    }

    function onTouchEnd(e) {
      const t =
        (e.changedTouches && e.changedTouches[0]) ||
        (e.touches && e.touches[0]);
      if (!t) {
        activeTouch = null;
        return;
      }
      const hadInteraction = !!(activeTouch || pendingDrag || dragState);
      if (!hadInteraction) {
        activeTouch = null;
        return;
      }
      e.preventDefault();
      if (pendingDrag || dragState) {
        onMouseUp({
          clientX: t.clientX,
          clientY: t.clientY
        });
      }
      if (activeTouch && !activeTouch.moved && activeTouch.cardEl) {
        const now = Date.now();
        const dt = now - lastTapTime;
        const dx = t.clientX - lastTapX;
        const dy = t.clientY - lastTapY;
        const dist = Math.hypot(dx, dy);
        const cardId = activeTouch.cardEl.dataset.cardId;
        if (
          dt < DOUBLE_TAP_DELAY &&
          dist < DOUBLE_TAP_DISTANCE &&
          lastTapCardId === cardId
        ) {
          const fakeEvent = {
            preventDefault: () => {},
            stopPropagation: () => {},
            currentTarget: activeTouch.cardEl
          };
          onCardDoubleClick(fakeEvent);
          lastTapTime = 0;
          lastTapCardId = null;
        } else {
          lastTapTime = now;
          lastTapCardId = cardId;
          lastTapX = t.clientX;
          lastTapY = t.clientY;
        }
      }
      activeTouch = null;
    }

    function checkForWin() {
      const foundationsComplete = foundations.every((pile) => pile.length === 13);
      const allTableauFaceUp = tableau.every(col =>
        col.every(card => card.faceUp)
      );
      const drawDeckEmpty = stock.length === 0;
      const wasteEmpty = waste.length === 0;
      if (foundationsComplete || (allTableauFaceUp && drawDeckEmpty && wasteEmpty)) {
        statusEl.textContent = "You win!";
      }
    }
  </script>
</body>
</html>
